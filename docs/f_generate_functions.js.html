<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>f/generate_functions.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-Errors.BreakExecutionStepError.html">BreakExecutionStepError</a></li></ul><h3>Modules</h3><ul><li><a href="module-Backtest.html">Backtest</a><ul class='methods'><li data-type='method'><a href="module-Backtest.html#.backtest">backtest</a></li><li data-type='method'><a href="module-Backtest.html#.prepareData">prepareData</a></li></ul></li><li><a href="module-Errors.html">Errors</a></li><li><a href="module-Execution.html">Execution</a><ul class='methods'><li data-type='method'><a href="module-Execution.html#.execStrategyStep">execStrategyStep</a></li><li data-type='method'><a href="module-Execution.html#.execStrategyStepWithBreak">execStrategyStepWithBreak</a></li><li data-type='method'><a href="module-Execution.html#.processPendingBacktestOrders">processPendingBacktestOrders</a></li></ul></li><li><a href="module-F.html">F</a><ul class='methods'><li data-type='method'><a href="module-F.html#.evaluateCondition">evaluateCondition</a></li><li data-type='method'><a href="module-F.html#.f.breakIf.indicators">f.breakIf.indicators</a></li><li data-type='method'><a href="module-F.html#.f.closePosition">f.closePosition</a></li><li data-type='method'><a href="module-F.html#.f.condition.indicators">f.condition.indicators</a></li><li data-type='method'><a href="module-F.html#.f.condition.threshold">f.condition.threshold</a></li><li data-type='method'><a href="module-F.html#.f.defineIndicators">f.defineIndicators</a></li><li data-type='method'><a href="module-F.html#.f.getIndicators">f.getIndicators</a></li><li data-type='method'><a href="module-F.html#.f.getPosition">f.getPosition</a></li><li data-type='method'><a href="module-F.html#.f.inPosition">f.inPosition</a></li><li data-type='method'><a href="module-F.html#.f.openPosition">f.openPosition</a></li><li data-type='method'><a href="module-F.html#.generateFunctions">generateFunctions</a></li><li data-type='method'><a href="module-F.html#.requireIndicators">requireIndicators</a></li></ul></li><li><a href="module-Indicators.html">Indicators</a><ul class='methods'><li data-type='method'><a href="module-Indicators.html#.addCandleForIndicator">addCandleForIndicator</a></li><li data-type='method'><a href="module-Indicators.html#.addTradeForIndicator">addTradeForIndicator</a></li><li data-type='method'><a href="module-Indicators.html#.forEachIndicator">forEachIndicator</a></li><li data-type='method'><a href="module-Indicators.html#.indicatorAcceptsCandles">indicatorAcceptsCandles</a></li><li data-type='method'><a href="module-Indicators.html#.indicatorAcceptsTrades">indicatorAcceptsTrades</a></li><li data-type='method'><a href="module-Indicators.html#.updateCandleForIndicator">updateCandleForIndicator</a></li><li data-type='method'><a href="module-Indicators.html#.updateIndicators">updateIndicators</a></li><li data-type='method'><a href="module-Indicators.html#.updateTradeForIndicator">updateTradeForIndicator</a></li></ul></li><li><a href="module-Orders.html">Orders</a><ul class='methods'><li data-type='method'><a href="module-Orders.html#.executeOrder">executeOrder</a></li></ul></li><li><a href="module-Positions.html">Positions</a><ul class='methods'><li data-type='method'><a href="module-Positions.html#.generatePosition">generatePosition</a></li><li data-type='method'><a href="module-Positions.html#.processPositions">processPositions</a></li></ul></li><li><a href="module-State.html">State</a><ul class='methods'><li data-type='method'><a href="module-State.html#.addHistoricalPosition">addHistoricalPosition</a></li><li data-type='method'><a href="module-State.html#.addPendingBacktestOrder">addPendingBacktestOrder</a></li><li data-type='method'><a href="module-State.html#.addTrade">addTrade</a></li><li data-type='method'><a href="module-State.html#.getDefaultSymbol">getDefaultSymbol</a></li><li data-type='method'><a href="module-State.html#.getIndicators">getIndicators</a></li><li data-type='method'><a href="module-State.html#.getLastPrice">getLastPrice</a></li><li data-type='method'><a href="module-State.html#.getPosition">getPosition</a></li><li data-type='method'><a href="module-State.html#.getPositions">getPositions</a></li><li data-type='method'><a href="module-State.html#.getState">getState</a></li><li data-type='method'><a href="module-State.html#.hasIndicators">hasIndicators</a></li><li data-type='method'><a href="module-State.html#.initState">initState</a></li><li data-type='method'><a href="module-State.html#.isBacktesting">isBacktesting</a></li><li data-type='method'><a href="module-State.html#.setLastCandle">setLastCandle</a></li><li data-type='method'><a href="module-State.html#.setLastTrade">setLastTrade</a></li><li data-type='method'><a href="module-State.html#.setState">setState</a></li><li data-type='method'><a href="module-State.html#.updateState">updateState</a></li></ul></li><li><a href="module-Trades.html">Trades</a><ul class='methods'><li data-type='method'><a href="module-Trades.html#.generateTrade">generateTrade</a></li></ul></li><li><a href="module-Utility.html">Utility</a><ul class='methods'><li data-type='method'><a href="module-Utility.html#.doError">doError</a></li><li data-type='method'><a href="module-Utility.html#.withinLastCandle">withinLastCandle</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#STATE_KEY">STATE_KEY</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">f/generate_functions.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

const { Map } = require('immutable')
const _isFinite = require('lodash/isFinite')

const evaluateCondition = require('./evaluate_condition')
const requireIndicators = require('./require_indicators')
const { BreakExecutionStepError } = require('../errors')
const { generatePosition } = require('../positions')
const { generateTrade } = require('../trades')
const { doError } = require('../util')
const {
  getDefaultSymbol, hasIndicators, getIndicators, updateState, getPosition,
  isBacktesting, getPositions, getLastPrice, addTrade, addHistoricalPosition
} = require('../state')

require('../types/indicator')

/**
 * Generates the F helper object for a strategy instance
 *
 * @memberOf module:F
 *
 * @param {Strategy} strategy - the strategy to configure the helpers for
 * @returns {F} f
 */
const generateFunctions = (strategy) => {
  const f = {}

  /**
   * Makes the provided indicators object an immutable Map and attaches it to
   * the strategy for usage with other functions. The indicators will be
   * automatically updated throughout the lifecycle of the function as new
   * data points arrive.
   *
   * @memberOf module:F
   * @example
   * await f.defineIndicators({
   *   l: new EMA([100]),
   *   s: new EMA([20])
   * })
   *
   * @param {object&lt;Indicator>} indicators - key'ed by ID
   */
  f.defineIndicators = (indicators) => {
    if (!hasIndicators(strategy)) {
      updateState(strategy, 'indicators', Map({ ...indicators }))
      updateState(strategy, 'hasIndicators', true)

      throw new BreakExecutionStepError('defined indicators')
    }
  }

  f.breakIf = {}

  /**
   * Helper to terminate execution early on the current update cycle if the
   * provided condition callback returns true.
   *
   * @memberOf module:F
   * @example
   * await f.defineIndicators({
   *   l: new EMA([100]),
   *   s: new EMA([20])
   * })
   *
   * await f.breakIf.indicators(({ s, l }) => s.crossed(l.v()))
   *
   * @param {Function} condition - should return true when control flow should
   *   break, can by async
   * @throws {Error} fails if the strategy does not have indicators configured
   */
  f.breakIf.indicators = async (condition) => {
    requireIndicators(strategy)

    const v = await condition(getIndicators(strategy).toJS())

    if (v) {
      throw new BreakExecutionStepError('awaiting indicator event')
    }
  }

  f.condition = {}

  /**
   * Helper to execute a callback when a condition operating on the indicator
   * map is met.
   *
   * @memberOf module:F
   * @example
   * return f.condition.indicators(({ s, l }) => s.crossed(l.v()), async ({ s, l } = {}) => {
   *   debug('indicators crossed: s:%f &lt;-> l:%f', s.v(), l.v())
   *
   *   if (f.inPosition()) {
   *     return f.closePosition()
   *   } else {
   *     return f.openPosition({ amount: 6 })
   *   }
   * })
   *
   * @param {Function} condition - async condition operating on indicators
   * @param {Function} cb - executed when the condition is truthy
   * @return {Promise} p - resolves after evaluation/potential execution
   */
  f.condition.indicators = async (condition, cb) => {
    requireIndicators(strategy)

    const indicators = getIndicators(strategy).toJS()
    const v = await condition(indicators)

    if (v) {
      await cb(indicators)
    }
  }

  // TOOD: extract

  /**
   * Calls the provided callback if the condition defined between the specified
   * indicator and value is met.
   *
   * @memberOf module:F
   * @see module:F.evaluateCondition
   * @example
   * await f.defineIndicators({
   *   l: new EMA([100]),
   *   s: new EMA([20])
   * })
   *
   * await f.condition.threshold('s', '>', 0.91, () => {
   *   // ...
   * })
   *
   * await f.condition.threshold('s', '=', 'l', () => {
   *   // ...
   * })
   *
   * @param {string} indicatorID - ID of indicator to evaluate
   * @param {string} condition - =, !=, >, >=, &lt;, or &lt;= (see reference)
   * @param {number} value - value
   * @param {Function} cb - called if condition is met
   * @returns {Promise} p - resolves on condition failure or callback completion
   *
   */
  f.condition.threshold = async (indicatorID, condition, value, cb) => {
    requireIndicators(strategy)

    const i = getIndicators(strategy).get(indicatorID)

    if (!i) {
      throw new Error(`no such indicator with ID: ${indicatorID}`)
    }

    const v = evaluateCondition(strategy, condition, i.v(), value)

    if (v) {
      await cb()
    }
  }

  /**
   * Utility to get the strategy's indicators as a POJO object, key'ed by ID
   *
   * @memberOf module:F
   *
   * @returns {object} indicators
   */
  f.getIndicators = () => getIndicators(strategy).toJS()

  /**
   * Query if strategy is currently in a position for the specified symbol.
   *
   * @memberOf module:F
   *
   * @param {string} [symbol] - defaults to default symbol
   * @returns {boolean} inPosition
   */
  f.inPosition = (symbol = getDefaultSymbol(strategy)) => {
    return !!getPosition(strategy, symbol)
  }

  /**
   * Get the position for the specified symbol, if it exists
   *
   * @memberOf module:F
   *
   * @param {string} [symbol] - defaults to default strategy symbol
   * @returns {Map} position
   */
  f.getPosition = (symbol = getDefaultSymbol(strategy)) => {
    return getPosition(strategy, symbol)
  }

  /**
   * Close an open position by symbol
   *
   * @memberOf module:F
   *
   * @param {string} [symbol] - position symbol
   * @throws {Error} fails if no position is open for the symbol and executing
   *   a backtest. Will only log an error during live execution.
   */
  f.closePosition = async (symbol = getDefaultSymbol(strategy)) => {
    const position = getPosition(strategy, symbol)

    if (!position) {
      return doError(`position not open for symbol: ${symbol}`)
    }

    if (!isBacktesting(strategy)) {
      throw new Error('live positions are WIP')
    }

    const price = getLastPrice(strategy, symbol)
    const positions = getPositions(strategy)
    const amount = position.get('amount') * -1
    const trade = generateTrade({ symbol, amount, price })

    updateState(strategy, 'positions', positions.delete(symbol))
    addHistoricalPosition(strategy, position)
    addTrade(strategy, trade)
  }

  /**
   * Open a position on the specified symbol for the specified amount. Supports
   * declaring a price target and stop-loss, which are triggered automatically
   * as part of the strategy execution cycle.
   *
   * @memberOf module:F
   *
   * @param {object} params - position parameters
   * @param {string} [params.symbol] - symbol, defaults to default strategy symbol
   * @param {amount} params.amount - amount
   * @param {amount} [params.target] - price target at which to automatically
   *   close the position
   * @param {amount} [params.stop] - stop price at which to automatically close
   *   the position
   * @throws {Error} fails if a position is already open for the symbol and
   *   executing a backtest. Will only log an error during live execution.
   */
  f.openPosition = async ({
    symbol = getDefaultSymbol(strategy),
    amount,
    target,
    stop
  } = {}) => {
    const price = getLastPrice(strategy, symbol)

    if (!_isFinite(amount)) {
      return doError(`invalid amount: ${amount}`)
    } else if (!_isFinite(price)) {
      doError(`(open position) no price data available for ${symbol}`)
    }

    if (getPosition(strategy, symbol)) {
      return doError(`position already open for symbol: ${symbol}`)
    }

    if (!isBacktesting(strategy)) {
      throw new Error('live positions are WIP')
    }

    const positions = getPositions(strategy)
    const trade = generateTrade({ symbol, amount, price })
    const newPosition = generatePosition(trade, { target, stop })

    updateState(strategy, 'positions', positions.set(symbol, newPosition))
    addTrade(strategy, trade)
  }

  // TODO: generic order submit; requires WSv2 listeners for live exec + planning

  return f
}

module.exports = generateFunctions
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Thu Mar 12 2020 17:23:11 GMT+0700 (Indochina Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
